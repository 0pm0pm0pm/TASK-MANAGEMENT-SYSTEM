from flask import Flask, request, jsonify, make_response
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime
import jwt  # PyJWT library
from functools import wraps
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship
from typing import List, Optional
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from flask_cors import CORS  # Import CORS

# App Configuration
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes.  Configure origins as needed.
app.config['SECRET_KEY'] = 'your-secret-key'  # Change this!  Use a long, random string.
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://your_user:your_password@localhost/your_database'  # Update with your database details!
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Suppress a warning
db = SQLAlchemy(app)
Base = declarative_base()
Session = sessionmaker(bind=db.engine)






# --- Helper Functions ---

def token_required(f):
    """
    Decorator to protect routes that require authentication.
    """
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'message': 'Token is missing!'}), 401

        try:
            token = token.split(" ")[1]  # Remove "Bearer " prefix
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=["HS256"])
            #  The current user is now accessible as kwargs['current_user'] in the route.
            user = User.query.filter_by(id=data['user_id']).first()
            if user is None:
                return jsonify({'message': 'Invalid Token! User not found'}), 401
            return f(current_user=user, *args, **kwargs)  # Pass user object
        except jwt.ExpiredSignatureError:
            return jsonify({'message': 'Token has expired!'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Invalid token!'}), 401
        except Exception as e:
            print(e)
            return jsonify({'message': 'An error occurred while decoding the token!'}), 401

    return decorated


def validate_input(data, required_fields):
    """
    Helper function to validate required fields in a request.
    """
    missing_fields = [field for field in required_fields if field not in data]
    if missing_fields:
        return jsonify({'message': f'Missing fields: {", ".join(missing_fields)}'}), 400
    return None  # Returns None if all fields are present


# --- Models ---

class User(Base):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    role = db.Column(db.String(20), default='member')  # e.g., 'admin', 'member', 'guest'
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    tasks: List['Task'] = relationship('Task', back_populates='assigned_user')
    projects: List['Project'] = relationship('Project', back_populates='created_by_user')

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f'<User(username={self.username}, email={self.email}, role={self.role})>'


class Project(Base):
    __tablename__ = 'projects'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    created_by = db.Column(db.Integer, ForeignKey('users.id'), nullable=False)
    created_by_user: User = relationship('User', back_populates='projects')  # Corrected backref name
    tasks: List['Task'] = relationship('Task', back_populates='project')

    def __repr__(self):
        return f'<Project(name={self.name})>'


# ---  Task based project --.
""""
Case for project task operations 
Due dates and activities 
Follow ups 
aand admin priveledeges  still in the process of establishment
"""
----#









# --- Routes ---

@app.route('/register', methods=['POST'])
def register():
    """
    Registers a new user.
    """
    data = request.get_json()
    error = validate_input(data, ['username', 'email', 'password'])
    if error:
        return error

    username = data['username']
    email = data['email']
    password = data['password']

    # Check if user already exists
    if User.query.filter_by(username=username).first():
        return jsonify({'message': 'Username already exists!'}), 400
    if User.query.filter_by(email=email).first():
        return jsonify({'message': 'Email address already exists!'}), 400

    new_user = User(username=username, email=email)
    new_user.set_password(password)
    db.session.add(new_user)
    db.session.commit()

    return jsonify({'message': 'Registered successfully!'}), 201



@app.route('/login', methods=['POST'])
def login():
    """
    Logs in a user and returns a JWT token.
    """
    data = request.get_json()
    error = validate_input(data, ['username', 'password'])
    if error:
        return error

    username = data['username']
    password = data['password']

    user = User.query.filter_by(username=username).first()
    if not user or not user.check_password(password):
        return jsonify({'message': 'Invalid credentials!'}), 401

    # Generate JWT token
    token = jwt.encode(
        {'user_id': user.id, 'exp': datetime.utcnow() +  datetime.timedelta(hours=24)},  # Token expires in 24 hours
        app.config['SECRET_KEY'],
        algorithm='HS256'
    )
    return jsonify({'token': token,
                    'user_id': user.id, #added user_id
                    'username': user.username,
                    'role': user.role}), 200 #Added info to the response



@app.route('/users', methods=['GET'])
@token_required
def get_users(current_user):
    """
    Returns a list of all users.  Requires a valid token.
    """
    if current_user.role != 'admin':
        return jsonify({'message': 'Unauthorized!'}), 403
    users = User.query.all()
    output = [{'id': user.id, 'username': user.username, 'email': user.email, 'role': user.role} for user in users]
    return jsonify({'users': output}), 200/
#---The next should be from flask import Flask, request, jsonify, make_response
from flask_sqlalchemy import SQLAlchemy
from werkzeug.security import generate_password_hash, check_password_hash
from datetime import datetime
import jwt  # PyJWT library
from functools import wraps
from sqlalchemy import ForeignKey
from sqlalchemy.orm import relationship
from typing import List, Optional
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from flask_cors import CORS  # Import CORS

# App Configuration
app = Flask(__name__)
CORS(app)  # Enable CORS for all routes.  Configure origins as needed.
app.config['SECRET_KEY'] = 'your-secret-key'  # Change this!  Use a long, random string.
app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://your_user:your_password@localhost/your_database'  # Update with your database details!
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # Suppress a warning
db = SQLAlchemy(app)
Base = declarative_base()
Session = sessionmaker(bind=db.engine)


# --- Helper Functions ---

def token_required(f):
    """
    Decorator to protect routes that require authentication.
    """
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization')
        if not token:
            return jsonify({'message': 'Token is missing!'}), 401

        try:
            token = token.split(" ")[1]  # Remove "Bearer " prefix
            data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=["HS256"])
            #  The current user is now accessible as kwargs['current_user'] in the route.
            user = User.query.filter_by(id=data['user_id']).first()
            if user is None:
                return jsonify({'message': 'Invalid Token! User not found'}), 401
            return f(current_user=user, *args, **kwargs)  # Pass user object
        except jwt.ExpiredSignatureError:
            return jsonify({'message': 'Token has expired!'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'message': 'Invalid token!'}), 401
        except Exception as e:
            print(e)
            return jsonify({'message': 'An error occurred while decoding the token!'}), 401

    return decorated


def validate_input(data, required_fields):
    """
    Helper function to validate required fields in a request.
    """
    missing_fields = [field for field in required_fields if field not in data]
    if missing_fields:
        return jsonify({'message': f'Missing fields: {", ".join(missing_fields)}'}), 400
    return None  # Returns None if all fields are present


# --- Models ---

class User(Base):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    email = db.Column(db.String(100), unique=True, nullable=False)
    password_hash = db.Column(db.String(128), nullable=False)
    role = db.Column(db.String(20), default='member')  # e.g., 'admin', 'member', 'guest'
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    tasks: List['Task'] = relationship('Task', back_populates='assigned_user')
    projects: List['Project'] = relationship('Project', back_populates='created_by_user')

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

    def __repr__(self):
        return f'<User(username={self.username}, email={self.email}, role={self.role})>'


class Project(Base):
    __tablename__ = 'projects'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    description = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    created_by = db.Column(db.Integer, ForeignKey('users.id'), nullable=False)
    created_by_user: User = relationship('User', back_populates='projects')  # Corrected backref name
    tasks: List['Task'] = relationship('Task', back_populates='project')

    def __repr__(self):
        return f'<Project(name={self.name})>'


class Task(Base):
    __tablename__ = 'tasks'
    id = db.Column(db.Integer, primary_key=True)
    project_id = db.Column(db.Integer, ForeignKey('projects.id'), nullable=False)
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text)
    due_date = db.Column(db.DateTime)
    priority = db.Column(db.String(20), default='Medium')  # e.g., 'High', 'Medium', 'Low'
    status = db.Column(db.String(20), default='To Do')  # e.g., 'To Do', 'In Progress', 'Done'
    assigned_to = db.Column(db.Integer, ForeignKey('users.id'))
    assigned_user: Optional['User'] = relationship('User', back_populates='tasks')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    project: Project = relationship('Project', back_populates='tasks')

    def __repr__(self):
        return f'<Task(title={self.title}, status={self.status}, priority={self.priority})>'



# --- Routes ---

@app.route('/register', methods=['POST'])
def register():
    """
    Registers a new user.
    """
    data = request.get_json()
    error = validate_input(data, ['username', 'email', 'password'])
    if error:
        return error

    username = data['username']
    email = data['email']
    password = data['password']

    # Check if user already exists
    if User.query.filter_by(username=username).first():
        return jsonify({'message': 'Username already exists!'}), 400
    if User.query.filter_by(email=email).first():
        return jsonify({'message': 'Email address already exists!'}), 400

    new_user = User(username=username, email=email)
    new_user.set_password(password)
    db.session.add(new_user)
    db.session.commit()

    return jsonify({'message': 'Registered successfully!'}), 201



@app.route('/login', methods=['POST'])
def login():
    """
    Logs in a user and returns a JWT token.
    """
    data = request.get_json()
    error = validate_input(data, ['username', 'password'])
    if error:
        return error

    username = data['username']
    password = data['password']

    user = User.query.filter_by(username=username).first()
    if not user or not user.check_password(password):
        return jsonify({'message': 'Invalid credentials!'}), 401

    # Generate JWT token
    token = jwt.encode(
        {'user_id': user.id, 'exp': datetime.utcnow() +  datetime.timedelta(hours=24)},  # Token expires in 24 hours
        app.config['SECRET_KEY'],
        algorithm='HS256'
    )
    return jsonify({'token': token,
                    'user_id': user.id, #added user_id
                    'username': user.username,
                    'role': user.role}), 200 #Added info to the response



@app.route('/users', methods=['GET'])
@token_required
def get_users(current_user):
    """
    Returns a list of all users.  Requires a valid token.
    """
    if current_user.role != 'admin':
        return jsonify({'message': 'Unauthorized!'}), 403
    users = User.query.all()
    output = [{'id': user.id, 'username': user.username, 'email': user.email, 'role': user.role} for user in users]
    return jsonify({'users': output}), 200



# --- Initialize Database ---
with app.app_context():
    db.create_all() #moved to inside app context


if __name__ == '__main__':
    app.run(debug=True)




# --- Initialize Database ---
with app.app_context():
    db.create_all() #moved to inside app context


if __name__ == '__main__':
    app.run(debug=True)
